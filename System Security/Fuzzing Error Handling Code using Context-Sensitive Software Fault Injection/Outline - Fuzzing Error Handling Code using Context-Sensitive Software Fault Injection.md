# Outline

## Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection - USENIX Security 2020

Created by : Mr Dk.

2020 / 06 / 18 10:53

Nanjing, Jiangsu, China

---

## Abstract

在实际中，**错误处理代码** 很难被测试到。即使是通过 fuzzing，也只能测试那些可以被特定输入触发的错误处理代码。然而另一部分错误处理代码，只能偶尔被触发 (内存分配失败 / 网络传输失败)，因此很难被触发。

已有工具使用 context-insensitive 的 *软件错误注入 (Software Fault Injection, SFI)* 来测试错误处理代码。本文提出 context-sensitive 的 SFI，能够测试到 context-insensitive SFI 测试不到的错误处理代码。

## Introduction

测试错误处理代码的难点在于，很难重现确定性的错误。一种可行的方式是，在测试程序中故意注入错误，并测试其在运行时是否能够处理这个错误。这种方法目前的局限在于，错误的注入是上下文不敏感的，只根据源代码中的错误位置注入错误，而没有考虑执行上下文，阻止了更加深层的测试。

对于某一个代码中的错误点，目前的方法会直接在这个位置注入错误，代码执行到这里的时候每次都会遇上错误；而在实际中，可能只有某几个调用上下文才会在这个位置触发错误，其它情况不会触发错误。这样一来，上下文不敏感的错误注入会导致错过一些 bug。以下是一个例子：

```c
int main() {
    x = malloc(...);
    y = malloc(...);
    
    FuncA(x);
    FuncB(y);
}

void FuncA(x) {
    FuncP(x);
}

void FuncB(y) {
    free(y);
    FuncP(y);
}

void FuncP(arg) {
    z = malloc(...);
    if (!z) {
        free(arg);
        exit(-1);
    }
}
```

假设使用上下文敏感的错误注入，直接将错误注入到 `FuncP()` 的 `z = malloc(...);` 处，也就是每次都让 `z` 为 `NULL`，从而触发之后的错误处理代码。那么每次执行这个程序，都是由 `FuncA()` 进入 `FuncP()` 然后错误退出。

然而，如果使用上下文敏感的错误注入，从 `FuncA()` 进入 `FuncP()` 时 `z = malloc(...);` 不产生错误，而从 `FuncB()` 进入 `FuncP()` 时使 `z` 为 `NULL`，那么将会出现一次 double-free bug。这就是本文出现的上下文敏感的错误注入的意义，能够动态地基于 **位置** 和 **调用上下文** 注入错误。

## Background

程序中的错误可以被分为两类：

* 与不合法的输入相关的错误 - 可用特定的输入触发
* 偶发错误 - 由一些偶尔发生的异常触发，与执行环境和系统资源相关，无法由特定输入触发

人工分析可能触发错误处理代码的方式：`if` 或 `goto` 语句。其中 42% 的错误处理代码入口是由偶发错误触发的；70% 的错误代码触发都是由检测代表错误的 return value 相关。因此，对返回值进行操作，就可以覆盖大部分的错误处理代码。

## Basic Idea and Approach

### Basic Idea

**错误点** 代表一个可能触发错误处理代码的代码执行点。当进行错误注入时，每个错误点可以正确运行 (用 `0` 表示) 或通过错误注入使其运行失败 (用 `1` 表示)。从而，在运行时得到了一个描述程序中所有错误情况的 0-1 序列。对这个序列进行 mutation，可以逐步 cover 尽可能多的错误处理函数。

### Error Sequence Model

关于错误点的模型。在上下文不敏感的错误注入中，只使用错误点在源代码中的位置来描述一个错误点，而没有考虑执行上下文。一个错误点可能在不同的执行上下文中被执行到，有的上下文中会触发 bug，有的上下文中不会触发 bug。为解决这个问题，除了错误点的位置以外，还需要记录上下文信息：调用栈中的每个调用的信息 (被调用的函数及其位置)。根据上述信息，将每个错误位置与上下文 hash 为一个 key，作为一个错误点。每个错误点的取值可以是 `0` 或 `1`。

上下文敏感的错误点无法通过静态分析获得，只能在程序运行时动态识别。

### Context-Sensitive SFI-based Fuzzing

通过程序的反馈信息，来指引对于上述错误点的 fuzzing。

1. 静态识别源代码中的错误位置 (静态分析 + 人工分析)
2. 运行程序，采集每个错误位置的调用上下文和 coverage
3. 建立错误点序列
4. 每次运行程序后，修改错误序列中的任意一个错误点 (变异)
5. 重新运行程序
6. 采集运行时信息，产生新的错误序列，变异序列，构成循环

在运行过程中采集 coverage，丢弃 coverage 重复的错误序列。所有引发 coverage 提升的错误序列会被保存下来，并根据 coverage 进行排名，用排名靠前的序列进行进一步的变异。

最开始的错误序列是全 `0` 的，初始变异把某一个 `0` 变为 `1` (相当于在某个错误点注入错误)，并检查 coverage 是否提升 (触发了新的错误处理代码)。在之后的循环中，通过把某一个位置的 `0` 或 `1` 进行翻转，产生新的序列，丢弃重复序列。

在运行时，需要动态查询当前调用上下文与错误点是否匹配。

## *FIFUZZ* Framework

使用基于 LLVM 字节码的代码分析 + 注解完成所有功能。

### Compile-Time Analysis

使用静态分析找到测试程序中的所有可能的错误点。大部分错误点都是判断函数调用的返回值。因此通过以下两个原则进行过滤：

1. 函数调用返回一个指针或 `int`
2. 返回值在一个 `if` 中被检查是否是 `NULL` 或 `0`

只检查对 **库函数** 的返回值进行错误处理的函数。检查所有调用这些 **库函数** 的函数，并计算其返回值被 `if` 语句检查的概率。如果这个概率高于一定阈值 R，那么就认为这是个错误点函数。所有调用了该函数的位置都会被作为错误点。**但是之后依旧需要进行人工分析**。另外，R 的取值也很重要，过高和过低都会带来误差。

接下来就是对代码进行注解。如果该错误点在当前错误序列中的值为 `1`，那么函数不执行，直接返回一个 `NULL` 或随机负数 (注入错误)；如果值为 `0`，那么函数正常执行。

### Runtime Fuzzing

关于测试输入的产生，还是直接选用了 AFL。另外，为了检测 bug 是否出现，除了观察 crash 以外，还可以使用第三方的 sanitizer 监控内存的使用。它们可以报告没有发生 crash 的内存错误。当然 fuzzing 性能可能会受到一定影响。

---

实验结果表明，与上下文不敏感的错误注入方法相比，*FIFUZZ* cover 了更多的错误处理代码。另外，coverage 的效果还受到程序输入的影响，因此改进上层的 AFL 也可以提升 *FIFUZZ* 的效果。

---

