# Outline

## Ex-vivo dynamic analysis framework for Android device drivers - S&P 2020

Created by : Mr Dk.

2020 / 06 / 11 11:51

Nanjing, Jiangsu, China

---

## Abstract and Introduction

OS 设备驱动代码大多 **肤浅地** 依赖于硬件和内核，因此对于 Android 驱动的脱机分析其实并不需要移植仿真。本文通过为设备驱动构建一个伪软硬件环境，使驱动能够在脱机的条件下完成初始化。使用成功初始化的驱动快照，可以使用用户空间工具基于这个快照对驱动代码进行 fuzzing。

## Introduction

设备制造商会通过加入驱动的方式定制 Android 内核，以支持手机上的外设。这部分驱动代码没有像内核核心代码那样经过严格审查。

驱动代码的动态分析可以分为在线 (on-device) 的和离线 (脱机) 两类：在线分析的优势在于准确性，而实用性较差。因为驱动分析需要特殊的硬件 + 内核，对于 Android，这两者很难满足：

* Android 设备只能从签名后的内核上启动
* 一些依赖于 Intel PT 的技术无法在 ARM 上使用
* 需要很多不同型号的设备

相比之下，离线分析通常在一个硬件仿真环境中进行：

* 效率高
* 可以对执行过程进行监控
* 可以在 CPU 上并行执行

但其很难部署到仿真器上的原因：

* 一些特定的硬件依赖在目前的仿真器上无法满足 (设备没有说明书)
* 驱动需要宿主内核中的一些软件依赖，受制于仿真器，也无法满足

仿真器中只能运行几个特定版本的内核，并且驱动需要被移植到可被仿真的内核中，工作量很大。

本文提出的方法可以进行脱机仿真，同时不需要移植驱动，对物理设备也没有要求。作者发现驱动对于硬件和软件确实存在依赖，但依赖的程度很肤浅：

* 可能只依赖于读取一个设备寄存器，而并不在意读取的真正内容是什么
* 可能依赖于一个函数返回的成功 code，而并不在意函数的实际作用

因此，实际上不需要精确仿真所有的依赖，而是为驱动营造一个所有依赖都满足的假环境。在这个环境中，驱动能够成功初始化，记录这个初始化状态的快照，使用仿真器运行这个快照，并使用用户空间工具 (如 AFL) 对 IOCTL 系统调用进行 fuzzing。

## Background

### Loadable Kernel Modules

大部分设备驱动都被编译为可装载模块，可以在系统启动之后动态链接到内核中。一旦内核模块被装载，那么就具有与其它内核代码相同的特权级。

### Platform Bus and Device Tree Files

大部分 Android 设备都是通过 platform bus 集成到主板。系统开发者需要使用 device tree file 配置内核以管理这些外设。这个文件描述了特定主板的硬件配置，并提供了每个外设的明文描述。编译后的 device tree file 在内核启动时被使用，使内核能够知道主板上有哪些设备。

老的内核使用 board file，通过用纯 C 描述设备，并直接编辑到内核中。

### Module Loading and Initialization

当模块加载到内核中时，首先进行的是链接过程 (符号重定位)。模块可能会在运行时调用宿主内核的函数，但是函数的具体位置在模块被编译时是不知道的。当模块被加载时，内核使用模块的重定位表，将模块调用的内核函数链接到实际位置。如果内核中没有模块需要的函数，那么模块加载失败。

模块加载成功后，内核会调用模块中的几个函数，完成驱动程序和外设的初始化。首先，内核会调用 `init_module`，将驱动注册到设备总线上，并提供一个 `probe` 函数的指针。与总线相关的代码会从 device tree file 中找到一个匹配的设备，并调用驱动的 `probe` 函数，用于在 `/dev/` 中创建新的设备文件，并注册设备的系统调用 handler (read/write/ioctl)。之后，对这个设备的操作将会被已注册的 handler 处理。

## The Evasion Kernel

这个内核用于加载、初始化其它内核中的驱动，并提供：

* 软件依赖
* 硬件依赖
* 内核数据结构依赖

驱动需要在初始化时设置其上下文，其中包含很多重要的内核数据结构、全局变量等。如果上下文没有被初始化，而直接执行驱动的函数，将会导致 crash。该内核的目标就是使驱动能够成功被初始化。

### Software Dependencies

截获模块的重定位请求，将模块初始化时需要调用的内核函数重定向到某几个伪函数中：

* 返回 0
* 返回 1
* 返回一个内存区

### Hardware Dependencies

忽略驱动向设备寄存器端口的读写请求。

### Kernel-driver API Structures Layout

由于不同的编译配置，结构体中的一些 field 将不会被编译，导致结构体的长度、定义不一致。

---

