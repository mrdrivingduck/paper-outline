# Outline

## GasFuzz: Generating High Gas Consumption Inputs to Avoid Out-of-Gas Vulnerability

Created by : Mr Dk.

2020 / 03 / 04 20:11

Ningbo, Zhejiang, China

---

## Abstract

当一个输入导致执行 smart contract 消耗很多 gas 时，将会产生 out-of-gas 异常，可被利用于 DoS 攻击。因此，需要对 smart contract 中函数的 gas limit 作估计，从而避免这样的错误。当 contract 较为复杂时，通常的估计方法会带来低估或高估的问题。

本文提出的 _GasFuzz_ 是一个自动产生输入的工具，该输入能够最大化 gas cost，从而成为 gas limit 的下界，解决了 gas limit 被低估的问题；另外，对于一些被其它工具估计为 gas limit 无限大的 contract，_GasFuzz_ 又能为 gas limit 找到一个合理的上界。

总之，_GasFuzz_ 基于 fuzzing 的技术，自动对产生的输入进行变异，并代入 contract 中，使该输入的执行 gas 尽可能地高。这个最高的 gas 值就可以被作为 gas limit。

---

## 1. Introduction

恶意用户会利用精心制作的输入，触发一个 gas 消耗量极大的交易，从而引发 DoS。因此很多工作聚焦于如何估计 smart contract 函数的 gas limit：

* 静态分析
* 符号执行

带来的问题是分析不准确，要么是低估，要么是估计不出上限 (无限)，要么是结果不正确。这项工作的两个主要挑战：

1. 一个交易的 gas 消耗不仅来自于执行操作码的消耗，还来自于对 storage (状态变量) 的操作 - 因此静态分析或符号执行无法准确估计
2. 函数中分支较多，人为产生输入也无法准确估计

_GasFuzz_ 使用了一种基于输入执行的反馈来指引的 fuzz testing。主要分为三步：

1. 产生带有权重的 CFG (每个 node 的权重就是该 node 的 gas cost)
2. 基于输入反馈的种子选取与变异
3. Contract 执行，计算输入的 gas 消耗

目标是找到对于一个函数来说，gas 消耗最大的一组输入。

在 _js-evm_ 上进行了测试。如果使用 _solc_ 编译器提供的 gas 估计功能，44.02% 的交易都会触发 out-of-gas；33.43% 的交易会被评估为 _无上限_ ，从而误导用户设置一个很高的 gas limit。_GasFuzz_ 能够将低估 gas limit 的交易比例减少到 13.86%，并为所有的 _无上限_ 交易找到一个有意义的上限值。另外，与其它 fuzzing 工具相比，_GasFuzz_ 能够在更短的时间内，对 97.8% 的交易产生相同或更高的 gas 估计值。

---

## 2. Overview

### 2.1 Background of Blockchain and Gas

Gas 是一个用于衡量操作的工作量的单位。这一机制保证了 EVM 资源不会被恶意浪费。在进行实际的交易时，用户需要指定，对当前的交易，愿意支付的最大 gas 量，即 gas limit。如果交易实际上消耗的 gas 值超过了 gas limit，那么交易 (contract 的执行) 就会引发 out-of-gas 异常而失败。

Out-of-gas 发生会导致已经消耗的 gas 全被浪费了，虽然交易没有完成。另外，将 gas limit 设得太高也不好：矿工一般更愿意处理 gas limit 较低的交易，这意味着交易完成的速度快；此外，较高的 gas limit 意味着允许更多的操作码执行，为攻击者提供了攻击的机会。

### 2.2 A Motivating Example

本文的目标是帮助用户更准确地设置 gas limit。以太坊中，有两种 gas 消耗机制：

1. 执行 gas 消耗
   * 执行 contract 时的计算操作
2. 交易 gas 消耗
   * 向区块链发送数据

而其中，交易消耗又包含以下四个部分：

1. 交易的基础消耗 (21000 gas units)
2. 部署 contract 的消耗 (构造函数，32000 gas units)
3. 对于交易中数据或代码的值为 0 的字节
4. 对于交易中数据或代码的值不为 0 的字节

在一个实际的例子中，一个 `CALL` 操作码的 gas 消耗包含：

1. 基本的 gas 消耗 (700 units)
2. 如果转账金额非 0 (9000 units)
3. 如果目标账户不存在 (25000 units)

以上是操作码的 gas 消耗。在实际交易中，对合约中状态变量的操作也需要 gas。

如果用户能提前知道这个函数会消耗多少 gas，就可以避免 out-of-gas error。

### 2.3 Gas Fuzzing Idea

_GasFuzz_ 的主要思想是保留可以引发更多 gas cost 的输入。对于一个输入，_GasFuzz_ 将记录 CFG 上每一条边的 gas cost，以及整个交易的总 gas cost。每一轮迭代中，_GasFuzz_ 都会从 seed pool 中随机选择一个，并进行随机的变异，然后输入 contract，反复进行。

如果新输入在 CFG 的边上没有产生更高的 gas 消耗，也没有产生整体更高的 gas 消耗，那么这个输入就会被丢弃；否则输入就会被保留在 seed pool 中，同时更新每一条边和整体的 gas cost。所有保留在 seed pool 中的输入都会被用于变异产生新的输入，优先选择 gas cost 更高的输入进行变异。_GasFuzz_ 同时保留了 __局部最高消耗__ 和 __全局最高消耗__ 的输入。

如果 _GasFuzz_ 能产生一个输入，其 gas 消耗比 contract 中的 gas limit 高，那么攻击者就有机会利用这样的输入进行攻击。本文找到了类似的 CVE。

---

## 3. _GasFuzz_ Design

首先，输入 contract 的二进制文件和 ABI 文件。提取 ABI 中各个函数的参数类型，并随机产生初始输入。将 contract 部署后，使用初始输入执行 contract，并记录 W-CFG 中每一条边的 gas cost 作为反馈信息。然后这一输入和反馈被用于进行 seed 选择和 seed 变异。如果变异后的输入能够触发更多的 gas cost，那么就会被留在 seed pool 中。

### 3.1 W-CFG Generation

在传统的 CFG 中，为每一个 node 记录 gas 消耗量，称为权重。CFG 的每个 node 都是顺序执行不分支的操作码。一个 node 的 gas 消耗量可能是不确定的。每个 node 都会有一个初始的 gas 消耗量 (如果某个 node 的 gas 消耗量不确定，那么该初始值就是这个 node 的最小 gas 消耗量)，初始 gas 消耗量为 0。一条边的 gas 消耗量被定义为这条边的根结点的 gas 消耗量。

### 3.2 Feedback-directed Selection and Mutation

在 test case 执行过程中，收集反馈信息：

* 每条边的 gas cost
* 每条边被走过的次数
* 总体的 gas cost

过程：

* Seed selection - 决定一个 seed 好不好
  * 变异后的输入消耗了更多的 gas / 命中了 W-CFG 中的边更多次
  * 所有 seed 存储在一个优先队列中 (seed pool) - 消耗的 gas 越多越优先
  * 每轮迭代中，从 seed pool 中选择一个进行变异
  * 使用了 _MCMC_ 选择方式，避免了局部最优问题
* Seed mutation - 决定一个 seed 如何被变异
  * 传统变异 - AFL 中的方法
  * Gas-cost 变异 - 对一些特定类型的变量进行变异，比如数组 (产生新的长度和元素的数组)

### 3.3 Contract Execution

构建 contract 运行的环境。部署 contract，并准备好执行每一个函数的初始输入。

---

## 4. Evaluation

### 4.1 Risks of Out-of-gas Error

使用 _solc_ 编译器的估计结果来研究 out-of-gas 带来的危害。定义 `diff` 为 _solc_ 的预计 gas cost 值与实际交易中的 gas 消耗值的差值。研究发现，如果用户使用 _solc_ 的预测值作为 gas limit，44.02% 的交易将会发生 out-of-gas (即 _solc_ 低估了 gas cost)；33.43% 的交易会被估计为 _无上限_ (高估，且找不到上界) ，从而没有什么指导性的作用。

选取了 8 个最有可能导致 out-of-gas 的函数进行评估。如果使用 _solc_ 的预测值，这些函数的交易中，93.3% 都会产生 out-of-gas。低估的原因是 _solc_ 使用静态分析来计算所有操作码的 gas 消耗，漏掉了 storage 的 gas 消耗。此外，如果函数中包含了复杂的循环，循环的次数取决于输入，那么每个操作码的执行次数就不确定了，从而被预测为 _无上限_ 。

### 4.2 _GasFuzz_ Performance

首先，86.14% 的 _GasFuzz_ 预测值都高于真实的 gas 消耗，而只有 22.55% 的 _solc_ 预测值高于真实的 gas 消耗。因此，_GasFuzz_ 的预测值能够有效降低 out-of-gas 的风险。

另外，_GasFuzz_ 能够产生高于 _solc_ 预测值 20% 的输入。

将所有的交易记录分为几类：

1. _GasFuzz_ 预测值 ＜ _solc_ 预测值 / 真实 gas 消耗
   * ...?
2. _solc_ 预测值 ＜ _GasFuzz_ 预测值 ＜ 真实 gas 消耗
   * 作者解释为可能是由于 fuzzing 的时间不够......还没有发现最烧 gas 的输入
3. _solc_ 预测值 / 真实 gas 消耗 ＜ _GasFuzz_ 预测值
   * 那么，如果使用 _GasFuzz_ 产生的输入，就会产生 out-of-gas
4. 真实 gas 消耗 ＜ _GasFuzz_ 预测值 ＜ _solc_ 预测值
   * 如果一些操作码将一些非 0 值改变为 0 时，可能会退回一些 gas；但退回的 gas 最高不超过 15000 - _solc_ 没有考虑这部分的 gas，因此估计值过高

### 4.3 _GasFuzz_ Engine

与其它的 fuzzing 工具进行了横向比较。

第一，比较 CFG 的反馈机制上的不同。有的 fuzzing 工具只保留最大化 CFG 路径的 seed (总路径最大)；有的 fuzzing 工具只保留执行 CFG 的边更多次的 seed (记录边的访问次数)。

第二，比较 fuzzing 引擎的不同 - 随机引擎将随机保存所有的 seed，不参考反馈信息。

_GasFuzz_ 的表现最好，因为 gas cost 不仅来自于执行操作码，还有访问 storage 的消耗。另外两种反馈机制不适合于这样的场景。

对于 fuzz 引擎的有效性，定义了 `GasRate = Result / Time`，即，能够在较短的时间内，发现 gas 消耗更大的输入。

### 4.4 Practical Applications

1. 预计 gas 的消耗量，用于设置 gas limit
2. 检测与 gas 消耗相关的威胁

---

## 5. Threats to Validity

### 5.1 Mutation and Selection Strategies Limitations

环境变量是随机生成的。应当构建一个拥有更多账号、更多状态信息的复杂环境。

### 5.2 Smart Contracts Support Limitations

目前的 _GasFuzz_ 无法处理调用另一个 contract 的情况。

### 5.3 Data Collection Limitations

---

