# Outline

## ContractFuzzer: Fuzzing Smart Contracts for Vulnerability Detection - ASE 2018

Created by : Mr Dk.

2020 / 02 / 18 19:22

Ningbo, Zhejiang, China

---

## Abstract

ContractFuzzer 通过 smart contract 的 ABI 说明来产生 fuzzing 输入，并定义了各类安全漏洞的规则。对 EVM 进行注解，通过日志记录 smart contract 的运行时行为，并分析这些日志，报告其中的安全漏洞。对 6991 个 smart contract 进行了检测，并以较高的准确率找到了 459 个漏洞。

---

## 1. Introduction

Smart contract 能够基于区块链的共识协议上构造去中心化的 APP。智能合约是运行在区块链上的，能定义任意的规则对数字资产进行控制。Decentralized Applications (DApps) 是由 smart contract 构成的后端和一系列 UI 构成的前端组成的。

然而，smart contract 的安全问题已经给区块链社区带来了重大损失。Smart contract 易受攻击的几个原因：

1. 智能合约的开发者无法完全理解 smart contract 之间的隐含关系
2. 编程语言 (Solidity) 和运行环境对于开发者来说比较新，工具也不够成熟
3. Smart contract 的不可修改性导致其在部署后很难被更新

在之前的工作中，一些 smart contract 验证工具局限于：

1. 检测策略不准确，high false positive rate
2. 符号执行所有可能的路径，可能会带来 path explosion 的问题

本文的主要贡献：

1. 第一个 Ethereum 平台上的 smart contract fuzzing 工具
2. 提出了能够精确检测出 smart contract 中漏洞的规则
3. 系统地 fuzzing 了 6991 个真实的 smart contract

---

## 2. A Review of Smart Contracts

### 2.1 The Basics of Smart Contracts on Ethereum

以太坊区块链平台支持：

* 外部账户 (由人持有)
* 智能合约账户

以太坊可被看作是基于 transaction 的状态机 - 每条 transaction 上链，状态就更新。每条 transaction 相当于一条从一个账户到另一个账户的消息，其中可能包含二进制数据，也可能包含 Ether。当消息的目标是一个 smart contract 账户时，smart contract 上的代码就被执行，消息中的 payload 就称为输入数据。

Smart contract 上的执行代码是运行于以太坊虚拟机 (EVM) 上的字节码。每一条 transaction 都会被收取一定的 gas 作为使用 EVM 资源的收费，以防止恶意代码浪费 EVM 资源。当 gas 用尽时，会抛出 out-of-gas 异常。

### 2.2 Vulnerabilities of Smart Contracts on Ethereum

安全问题可能发生在区块链层面、EVM 层面、smart contract 层面。

#### 2.2.1 Gasless Send

当调用 `send()` 时，接收方的 fallback 函数将会被调用，但 EVM 会指定该函数使用的 gas 为固定值 - 通常来说，当 `send()` 发送的数量为非零值时，fallback 函数的 gas 限制为 2300。

如果接收方 contract 的 fallback 函数执行代价昂贵，发送方就会产生 out-of-gas 异常。而如果在发送方没有 check 到这个异常而继续执行代码的话，一个恶意发送方就能错误地保留 ether。

#### 2.2.2 Exception Disorder

Solidity 对于异常处理不一致，具体取决于 contract 互相调用的方式。当一个 contract 调用另一个 contract 的函数时，可能会发生不同种类的异常而失败 - 当异常发生时，异常处理的机制由调用的方式决定：

* 如果一个嵌套调用链中，每一个调用都是 direct call - 那么当异常发生时，所有的 transaction 都会被复原，包括已经转账的 ether
* 当调用链中至少有一个通过地址进行的低层调用 (`call()` / `delegatecall()` / `send()`)，那么回滚将只会进行到该函数为止，并返回 `false`，然后代码又会继续执行；如果没有根据这个返回值进行判断，代码将无从得知已经发生了错误

#### 2.2.3 Reentrancy

开发者没有将一些函数设计为可重入。然而，恶意合约可以通过故意调用某些函数，重入这些函数，以窃取 ether。

#### 2.2.4 Timestamp Dependency

使用 block 的时间戳作为条件的一部分，进行一些重要的操作；或作为产生随机数的 seed。在区块链中，矿工在 900s 的时间间隔内可以自由选择 block 的时间戳 - 因此，攻击者有机会通过操纵 block 的时间戳来进行攻击。

#### 2.2.5 Block Number Dependency

与上一条类似，一些合约使用 block 中的数据作为一些重要操作的条件，或产生随机数的 seed。与时间戳类似，block 中的数据也是可以由矿工自由操纵的。另外，由于区块链具有透明性，对 block 中的数据进行 hash 也没什么用。

#### 2.2.6 Dangerous DelegateCall

Delegatecall 与普通的 call 相同，但区别在于目标地址的代码在调用者的上下文中执行。这意味着一个调用者可以在运行时从别的地址上动态加载代码，但是还是引用本地的存储空间。

然而，如果 delegatecall 的参数是 transaction 消息中的数据，那么攻击者就可以通过精心设计 transaction 中的消息，使受害者能够执行攻击者指定的任意函数。

#### 2.2.7 Freezing Ether

一些 contract 中可以接收 ether，也可以通过 delegatecall 发送 ether 到其它地址。然而，这些 contract 本身并不包含任何将 ether 发送到其它地址的函数。因此，当进行自毁操作时，contract 无法将其 ether 发送出去，从而导致这些 ether 被冻结。

---

## 3. Defining Testing Oracles for Vulnerabilities of Smart Contracts

### 3.1 Test Oracle for Gasless Send

在 EVM 中，`send()` 被实现为一种特殊的 `call()`。因此只需要判断 `call()` 的输入是否为 0，gas 限制是否为 2300 即可。

### 3.2 Test Oracle for Exception Disorder

在一些列嵌套调用中，当至少有一个函数发生异常时，root 没有抛出异常 - 即，异常没有正确地传播回 root，那么就可能发生 exception disorder。

### 3.3 Test Oracle for Reentrancy

基于两个规则：

1. 在调用 A 产生的调用链中，是否又会出现对 A 的调用
2. 检查三个条件
   1. 存在值大于 0 的 `call()` (有 ether 转账发生)
   2. 被调用者有足够的 gas 用于执行代码
   3. `call()` 的被调用者必须是本文工具提供的 agent contract，而不是其它的 contract

可重入的判断需要同时满足以上两个条件。即，能够满足重入攻击的条件。

### 3.4 Test Oracle for Timestamp Dependency

三个规则：

1. 当前 contract 在调用函数时是否使用了 `TIMESTAMP` 操作码
2. 检查 `call()` 是否是一个向其它 contract 转账的 `send()` 操作
3. `call()` 对其它 contract 的转账是否大于 0

判断满足当且仅当 1 和 (2 3 之一) 同时满足。即，当前 contract 使用了 block 时间戳，并且在执行期间发生了转账。

### 3.5 Test Oracle for Block Number Dependency

与上一条类似，区别不是判断是否使用了 block 的时间戳，而是 block 的数据 - 即 `NUMBER` 操作码。

### 3.6 Test Oracle for Dangerous DelegateCall

检测在执行期间是否有 `deletegate()` 被调用，且其调用的函数是由输入 (可能由潜在的攻击者) 决定。

### 3.7 Test Oracle for The Freezing Ether Contract

检测 contract 是否能够接收 ether、使用 `delegatecall()` 发送 ether，而 contract 本身没有 `transfer()` / `send()` / `call()` / `suicide()` 到其它地址的代码 - 即自身没有代码将 ether 转出去。

---

## 4. The Smart ContractFuzzer

### 4.1 An Overview of ContractFuzzer

大体上分为一个离线的 EVM 注解工具和一个在线的 fuzzing 工具。EVM 注解用于监控 smart contract 的执行，用于提取信息进行分析。

将 smart contract 爬取下来后，部署到测试网络中 - 用于 fuzzing 或用于以 smart contract 地址作为参数的函数。

在线 fuzzing 工具对被测试的 smart contract 的 ABI 接口和字节码进行分析。提取 ABI 函数的每个参数的数据类型和 ABI 函数中使用到的函数签名。基于这些分析结果，工具将能产生合法的 fuzzing 输入。函数签名被用于以合约地址为参数的 ABI 函数的输入。然后 fuzzing 工具就开始进行随机的函数调用。

最终，工具使用 fuzzing 过程中产生的执行日志来检测安全漏洞。Fuzzing 过程直到给定的时间用完时停止。

### 4.2 Static Analysis of Smart Contracts

#### 4.2.1 Analysis of ABI Function Signatures of Contracts Pool

对每个 smart contract 在 ABI 中暴露出的函数，提取这些函数的签名，并为每个函数签名计算 function selector (hash)。然后构造一个 Map：

* key - function selector
* value - vector<具有相同 selector 的 smart contract>

#### 4.2.2 Static Analysis of Smart Contract Under Test

对于被测试的 smart contract，根据其 ABI 中声明的函数，提取其函数声明和每个参数的数据类型。其中，有的参数的数据类型是地址，指向外部账户或另一个 contract 账户，这个参数可能在函数中被用于 `call()` 的调用。因此，对于这个参数，必须使用支持该函数调用的地址。

在函数实现中的 `call()` 调用处，`call()` 函数参数的前四个字节就是要调用的函数的签名 hash 的头四个字节，也就是 function selector。因此，作者对 ABI 函数中使用的 function selector 进行静态分析：

1. 对 smart contract 的字节码进行反汇编，提取所有的 public ABI 函数
2. 提取该函数的函数体，并寻找函数体中出现 `PUSH4` 的地方 (function selector)
3. 构造一个 Map
   * key 该函数
   * value 是该函数体中用到的所有 function selector

由于之前已经有了一个具有相同 function selector 的 smart contract 的 Map，通过该 Map，可以找到支持 function selector 的所有 smart contract 的地址。

当产生类型为地址的 fuzzing 输入时，就通过上述的 Map 找到合适的地址。

### 4.3 Fuzzing Input Generation

#### 4.3.1 Input Generation Based on ABI Interface

需要为每个函数产生合法的输入。对于长度固定的输入和长度不固定的输入，采用了两种策略。

对于长度固定的输入，首先根据数据类型随机产生一个合法的输入集合，然后基于静态分析，也构造一个该数据类型常用值的集合。将两个集合组合起来，成为该数据类型的候选值。

对于长度不固定的输入，先随机产生一个正数作为长度，然后再从输入域中随机选择作为元素。

ContractFuzzer 会对被测试的 contract ABI 中声明的每一个函数进行 fuzzing。因此，输入产生模块要对每一个函数产生一个候选输入集合。输入产生模块对每一个函数进行迭代，为每一个参数产生 k 的候选值。那么最终所有的输入是每个参数的 k 个候选值的组合。

#### 4.3.2 Input Generation for Reentrancy Vulnerability

需要产生一个重入攻击的场景，来尝试触发重入攻击。因此，构造一个 AttackerAgent 合约，与每一个 ABI 函数进行交互，从而测试这一场景。

### 4.4 Instrumenting EVM to Collect Test Oracles

基于上述提出的判断规则，需要在 EVM 中提取三类信息：

* `call()` 和 `delegatecall()` 的各种参数
* 执行期间的操作码
* 执行期间合约的状态

#### 4.4.1 Collecting Information on Call/DelegateCall/Send

一次函数调用需要被采集的信息：

* 函数调用者
* 函数被调用者
* 被调用的函数 (签名)
* 函数输入
* 函数传递的 ether
* 函数使用的 gas
* (是否在本合约上下文中执行) - delegateCall
* (操作码栈) - 用于查看函数调用链

在 EVM 中对于 `EVM.call()` 和 `EVM.DelegateCall()` 进行注解。

#### 4.4.2 Collecting Information on Opcode

注解了 EVM 解释器，将其遇到的每一条指令都 push 到操作码栈中。其中，选择了 34 条可能会被规则直接使用，或可能导致合约状态改变的字节码指令。

### 4.5 Vulnerability Analysis and Report

当初始函数调用的调用栈变空后 (函数结束)，将注解信息进行分析和判断。

---

## 5. Experiment and Results Analysis

### 5.1 Experiment Setup

将挖矿难度设置得很低，从而使得交易可以快速被确认，加快 fuzzing 速度。

### 5.2 Smart Contracts as Subject Programs

6991 的 smart contracts。

### 5.3 Experimental Procedure

首先对每个合约进行静态分析，为每个 ABI 函数准备好 private contract pool。然后开始产生输入。

对于每个 smart contract 的每个 ABI 函数，ContractFuzzer 将会使用三种账户调用它：

* 外部账户，该合约的 creator
* 外部账户，与该合约没有任何关系
* AttackAgent - 另一个 contract，用于测试重入攻击

对于这三种类型，以两种模式调用：

* 一种带 ether
* 一种不带 ether

对于每个 ABI 函数，如果有参数，ContractFuzzer 将会产生 k 个参数调用它，总共会被调用 6*k 次；否则就只调用 1 次 (空参数)，总共会被调用 6 次。将 k 设置为一个很大的值，从而有足够的测试机会。

对于每一个 smart contract，随机选择其函数开始 fuzzing。同时，结果会被收集、分析。

### 5.4 Experimental Results and Analysis

高准确率。

与最先进的 _Oyente_ 工具进行了对比 - 在 8 种威胁中，ContractFuzzer 能检测 7 种，而 _Oyente_ 只能检测 3 种。

### 5.5 Case Studies on Attacks on Vulnerable Smart Contracts

#### 5.5.1 Wrongfully Holding Ether of Investors

大致意思是，其它账户可以向合约进行投资。当投资数目超过了上限时，合约会把多出来的部分返回给源账户。而合约中没有对 `send()` 的返回值进行检验 - 如果 `send()` 操作失败，那么合约中就会错误地保留多出来的那部分 ether。

#### 5.5.2 Manipulating Timestamp to Win Slot Machine

合约中使用 block 的时间戳作为随机数，决定游戏的赢家。如果矿工也参与游戏，那么它可以根据偏好来操纵时间戳，从而赢得游戏。

#### 5.5.3 Relying on Hard-Coded Library to Transfer Ether

调用 library 中的函数来进行转账，然而代码本身并没有转账的代码 - 可能导致 ether 冻结。

---

